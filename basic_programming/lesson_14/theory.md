## Список уже полученных знаний и умений:

1 **Типы переменных (ТИП , имя, значение )**
int, double, long, char, float, short, byte, boolean - примитивные типы
String - сложный тип (ссылочный тип данных)
Вопрос: для чего нужны типы?
Ответ: Уменьшить/оптимизировать размер памяти под данные.

2 **Математические действия**
    
    + , - , * , / - целочисленное для int, % - остататок от деления (деление с остатком)
    Math.method - класс с изобилием математических функций.

3 **Накопление суммы/значения в переменной**

    sum = sum + 1; // так писали раньше
    sum++; // увеличение на 1
    sum--; // уменьшение на 1
    sum += 6 //увеличить на 6

4 **Вывод текста и "результатов" на экран**

    sout => System.out.println()
    System.out.println("Текст" + имя_переменной);

    System.out.printf("Текст %.2f (это шаблон)", имя_переменной); - это для форматированного вывода
    шаблон %.2f - числа с двумя знаками после запятой
    задаем формат вывода числа

5 **Запрос данных от пользователя** - число, строка, символ
Шаг 1.
Scanner scanner = new Scanner(System.in);
Шаг 2.
Создать переменную (задать тип и имя), куда поступит то, что будет набирать пользователь на клавиатуре
Шаг 3.
Выбрать правильный метод для приема данных от пользователя.

Не забывать писать приглашение пользователю для ввода данных!

6 **Проверка условия**

    выбор - if (логическое выражение) { ... } else { ... }  

    switch () {case: ...}

Тернарный оператор

    [первый операнд c условием] ? [второй операнд] : [третий операнд];
    третьего НЕ ДАНО!!! , boolean может быть только true, false

7 **Формальная логика, логические операторы**

Таблица логических операторов

    & - И (AND)
    && - тоже И, но если первое условие не выполнилось, то второе и не проверяется
    Пример: x > 0 && x < 10

    | - ИЛИ (OR)
    || - тоже ИЛИ, но если первое условие выполнилось, то второе и далее не проверяется

    ! - логическое отрицание
    !x означает “не x”. Меняет значение на противоположное
    
    ^ - Логическое исключающее ИЛИ (XOR)
    По сути, возвращает true, если операнды — разные.

Как и в математике, в программировании у операторов есть определённый порядок выполнения, если они встречаются в одном выражении:

    ! -> & -> ^ -> | -> && -> ||

Если одинаковые операции стоят по соседству, то раньше выполняется та, что левее.

8 **Проверка делимости нацело**

    if ( i % 2 == 0) - это делимость на 2
    число % 3 == 0, число % 5 == 0 - это делимость нацело на 3, 5

9 **Циклы:**

    while() {...}, 
    do {...} while(), 
    for (int i; i < ...; i++)

fori - часто применяемый,

10 **Массивы - объявление и наполнение**

        int[] array = new int[10]; // объявление и иннициализация массив целых чисел
        есть индекс у элемента массива, а есть сам элемент массива(значение) под этим индеском
        array[i] - это элемент массива, i - это его индекс, индексы начинаются с 0,
        array.length - это длина (размер / кол-во элементов) массива
        array.length - 1 -> это последний индекс в массиве
        array - это имя массива
        array[i] - это текущий элемент массива в цикле,
        array[i + 1] - это следующий за текущим элементом
        array[i - 1] - это предыдущий элемент перед текущим

11 **Генератор случайных чисел**

1.

     Random random = new Random();
     int var = random.nextInt(); // получаем случайное число в диапазоне всех значений типа int
     var = random.nextInt(50); // получаем случайное число в диапазоне от 0(включительно) до 50 (не включительно)
     var = random.nextInt(15) + 5; //получаем случайное число в диапазоне от 5(включительно) до 20 (не включительно)
     
     double varDouble = random.nextDouble();
     float varFloat = random.nextFloat();

2.

     int n = (int)(Math.random() * (m - n + 1) + n) - целые числа в интервале от n до m включительно!  
     кубик из 6 граней n = (int)(Math.random() * (6 - 1 + 1) + 1)
     орел и решка n = (int)(Math.random() * (1 - 0 + 1) + 0)

12 **Операции со строками:**

        st.length(); // получить длину строки
        st.equals(st1); // сравнить две строки по значению
        st.charAt() // получить символ из строки по его индексу
        st.substring(с какого места включительно, до какого места не включительно)


13 **Методы**

Методы - основные "строительные кирпичики" Java, для реализации различный функциональностей.

DRY (Don’t repeat yourself - не повторяйся) - основной принцип разработки программного обеспечения.
Методы позволяют реализовать этот принцип.

**Сигнатура метода** это совокупность имени метода и его параметров. Порядок параметров тоже важен в сигнатуре:

        [модификаторы] тип_возвращаемого_значения  название_метода (тип1 параметр1, тип2 параметр2){
        
        // тело метода
        
        }

Модификаторы и параметры не являются обязательными элементами в строке объявления метода, то есть могут отсутствовать.
Следует отметить, что существует некоторая путаница в определениях. Часто можно услышать, что строку объявления метода также называют сигнатура метода.
Но, все-таки, сигнатура метода - это то, что определяет уникальность метода при его вызове. Т.е. имя метода + набор параметров.


По умолчанию главный класс любой программы на Java содержит метод main, который служит точкой входа в программу.

Ключевые слова **public** и **static** являются модификаторами (альтернатива public - **private**,
отсутствие модификаторов - "по умолчанию", protected).

Далее идет **тип возвращаемого значения**.

Ключевое слово **void** указывает на то, что метод **ничего не возвращает**, он выполняет то, что в нем написано.

Вызов метода осуществляется в форме:

        имя_метода(аргументы);
        myMethod();

После имени метода обязательно указываются скобки, в которых перечисляются аргументы - значения для параметров метода.


Метод, если он не void, возвращает значение того типа, которое определено в его сигнатуре.
Для этого применяется оператор **return**.  
После оператора return указывается возвращаемое значение, которое является результатом метода.

Это может быть:
- значение переменной, которая вычислена в методе // return array;
- вычисляемое "на лету" выражение // return str + str1 -> будет сначала произведена конкатенация строк, потом возвращен результат
- литеральное значение (константа)